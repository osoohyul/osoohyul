<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>오수혈 풍선 터뜨리기 게임</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            overflow: hidden;
            touch-action: manipulation;
            background-color: #87CEEB;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 800px;
            margin: 0 auto;
            background: linear-gradient(to bottom, #1E90FF, #87CEEB);
            overflow: hidden;
        }

        .cloud {
            position: absolute;
            background: white;
            border-radius: 50%;
            filter: blur(5px);
            opacity: 0.8;
            z-index: 1;
        }

        .balloon {
            position: absolute;
            width: 70px;
            height: 90px;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: black;
            font-weight: bold;
            font-size: 16px;
            text-align: center;
            cursor: pointer;
            z-index: 2;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        }

        .balloon:after {
            content: '';
            position: absolute;
            bottom: -12px;
            left: 35px;
            width: 2px;
            height: 20px;
            background-color: #444;
            transform: translateX(-50%);
        }

        .balloon-pop {
            animation: pop 0.3s ease-out;
            opacity: 0;
        }

        @keyframes pop {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.5;
            }

            100% {
                transform: scale(0);
                opacity: 0;
            }
        }

@keyframes pulse {
    0% { opacity: 1; }
    100% { opacity: 0.7; }
}

      #slot-machine {
    position: absolute;
    bottom: 20px;  /* 아래쪽에 위치하도록 수정 */
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 600px;
    background-color: transparent;
    border-radius: 10px;
    padding: 0;
    z-index: 3;
    border: 8px solid transparent;
    background-clip: padding-box;
}

#slot-machine::before {
    content: '';
    position: absolute;
    top: -8px;
    left: -8px;
    right: -8px;
    bottom: -8px;
    background: linear-gradient(135deg, rgba(138, 43, 226, 0.7), rgba(75, 0, 130, 0.7), rgba(128, 0, 128, 0.7));
    border-radius: 15px;
    z-index: -1;
    opacity: 0.6;
    box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.4);
    backdrop-filter: blur(2px);
    animation: gradientShift 8s ease infinite;
}

@keyframes gradientShift {
    0% {
        background-position: 0% 50%;
    }
    50% {
        background-position: 100% 50%;
    }
    100% {
        background-position: 0% 50%;
    }
}

#timer-container {
    position: absolute;
    top: 10px;
    left: 47%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    z-index: 3;
}

#timer-icon {
    font-size: 24px;
    margin-right: 8px;
}

#timer-bar-container {
    width: 300px;
    height: 20px;
    background-color: rgba(255, 255, 255, 0.5);
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

#timer-bar {
    width: 100%;
    height: 100%;
    background: linear-gradient(to right, #FF5252, #FF8A80);
    border-radius: 10px;
    transition: width 1s linear;
}

#timer-text {
    margin-left: 8px;
    font-weight: bold;
    color: white;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
}

        #slot-display {
    height: 50px;
    background-color: #f0f0f0;
    border: none;
    border-radius: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    font-weight: bold;
    margin-bottom: 0;
    box-shadow: none;
    color: #333;
    background: linear-gradient(to bottom, #fffaf0, #f5f5dc);
    position: relative;
    overflow: hidden;
}

.slot-item {
    position: absolute;
    left: 0;
    width: 100%;
    text-align: center;
    opacity: 0;
}

        .flying-dart {
            position: absolute;
            width: 20px;
            height: 40px;
            background-color: transparent;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 40'%3E%3Cpath d='M10 0 L20 30 L10 40 L0 30 Z' fill='%23ff5722'/%3E%3C/svg%3E");
            z-index: 3;
        }

        #lives-container {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            z-index: 3;
        }

        .heart {
            width: 30px;
            height: 30px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z' fill='red'/%3E%3C/svg%3E");
            margin-right: 5px;
        }

#instruction-message {
    position: absolute;
    top: 70px; /* 시간바 아래쪽 위치 */
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 255, 255, 0.8);
    color: #333;
    padding: 10px 20px; /* 패딩도 약간 늘림 */
    border-radius: 20px;
    font-weight: bold;
    font-size: 22px; /* 글씨 크기 키움 */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    z-index: 3;
    text-align: center;
    opacity: 0; /* 처음에는 보이지 않음 */
    pointer-events: none; /* 클릭 이벤트를 통과시킴 */
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes fadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
}

.fade-in {
    animation: fadeIn 0.3s forwards;
}

.fade-out {
    animation: fadeOut 0.3s forwards;
}

        #score-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 10px;
            font-weight: bold;
            z-index: 3;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 4;
            display: none;
        }

        /* 기존 #restart-btn 스타일 (337번째 줄 근처)을 다음으로 교체: */
#save-score-btn {
    margin: 0 auto 5px auto;
    padding: 10px 20px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 18px;
    font-family: 'Noto Sans KR', sans-serif;
    display: block;
    min-width: 120px;
}

#save-score-btn:hover {
    background-color: #45a049;
}

#back-to-menu-btn {
    margin: 5px auto 0 auto;
    padding: 10px 20px;
    background-color: #f44336;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 18px;
    font-family: 'Noto Sans KR', sans-serif;
    display: block;
    min-width: 120px;
}

#back-to-menu-btn:hover {
    background-color: #d32f2f;
}

#restart-btn {
    margin-top: 5px;
    padding: 10px 20px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 18px;
    font-family: 'Noto Sans KR', sans-serif;
    min-width: 120px;
}

#restart-btn:hover {
    background-color: #45a049;
}

/* 게임 오버 텍스트 크기 조정 */
#game-over h2 {
    font-size: 24px;
    margin-bottom: 15px;
}

#game-over p {
    font-size: 19.2px; /* 24px의 0.8배 */
    margin: 10px 0;
}

/* 기존 @media screen and (max-width: 768px) 블록은 그대로 유지하되, 
   위의 버튼 스타일들만 제거 */

        /* 슬롯 머신 회전 애니메이션 */
@keyframes slotSpin {
    0% { transform: translateY(-150%); opacity: 0; }
    10% { transform: translateY(-80%); opacity: 1; }
    90% { transform: translateY(80%); opacity: 1; }
    100% { transform: translateY(150%); opacity: 0; }
}

.slot-spinning {
    animation: slotSpin 0.2s ease-in-out forwards;
}

@media screen and (max-width: 768px) {
    /* 풍선 크기 0.8배로 축소 */
    .balloon {
        width: 56px; /* 70px * 0.8 */
        height: 72px; /* 90px * 0.8 */
        font-size: 14px; /* 기존 16px에서 축소 */
    }
    
    .balloon:after {
        bottom: -10px; /* 기존 -12px에서 조정 */
        left: 28px; /* 기존 35px * 0.8 */
        height: 16px; /* 기존 20px * 0.8 */
    }
    
   /* 점수 컨테이너 높이를 0.8배로 줄이고 너비를 1.2배로 늘리며 텍스트 중앙 정렬 */
#score-container {
    display: flex;
    align-items: center; /* 세로 가운데 정렬 */
    justify-content: center; /* 가로 중앙 정렬 */
    padding: 7px 12px; /* 세로 패딩 유지, 좌우 패딩 증가 */
    height: 32px; /* 40px * 0.8 - 줄인 높이 유지 */
    font-size: 0.95em; /* 글자 크기 유지 */
    width: calc(100% * 1.2); /* 기본 너비의 1.2배 */
    max-width: 160px; /* 최대 너비 설정 */
    box-sizing: border-box; /* 패딩을 너비에 포함 */
}
    
    /* 하트 위치 조정 (크기는 원래대로) */
    #lives-container {
        top: 10px; /* 원래대로 */
        display: flex;
        align-items: center; /* 세로 가운데 정렬 */
    }
    
    /* 타이머 위치 조정 - 점수와 하트 바로 아래로 */
    #timer-container {
        top: 45px; /* 점수와 하트 바로 아래 */
        left: 50%; /* 중앙 정렬 */
        transform: translateX(-50%); /* 정확히 중앙 정렬 */
        justify-content: center; /* 내부 콘텐츠 중앙 정렬 */
    }
    
    /* 타이머 아이콘(자명종) 제거 */
    #timer-icon {
        display: none;
    }
    
    /* 타이머 바 컨테이너 중앙 정렬 */
    #timer-bar-container {
        margin-left: 0; /* 원래 마진 제거 */
    }
    
    /* 타이머 텍스트 위치 조정 */
    #timer-text {
        margin-left: 8px; /* 원래 간격 유지 */
    }
    
    /* 슬롯 머신 위치 및 높이 조정 */
    #slot-machine {
        bottom: 75px; /* 약간 더 위로 올림 */
        transform: translateX(-50%) scale(0.85); /* 가로 중앙 정렬 및 높이 0.85배 */
        transform-origin: center bottom; /* 변환 기준점을 하단 중앙으로 설정 */
    }
    
    /* 슬롯 디스플레이 높이 0.85배, 글자 크기는 원래대로 */
    #slot-display {
        height: 42.5px; /* 50px * 0.85 */
        font-size: 20px; /* 원래 글자 크기로 복원 */
    }
    
    /* 게임 오버 팝업 위치 조정 - 화면 중앙 */
    #game-over {
        top: 50%; /* 수직 중앙 */
        left: 50%; /* 수평 중앙 */
        transform: translate(-50%, -50%); /* 정확한 중앙 위치 */
        bottom: auto; /* bottom 속성 제거 */
    }
}
    </style>
</head>
<body>
    <div id="game-container">
    <div id="score-container">터뜨린 풍선: <span id="score">0</span></div>
    <div id="timer-container">
        <div id="timer-icon">⏰</div>
        <div id="timer-bar-container">
            <div id="timer-bar"></div>
        </div>
        <div id="timer-text">2:00</div>
    </div>
    <div id="lives-container"></div>
    <div id="instruction-message">알맞은 풍선을 클릭하세요!</div>
        <div id="slot-machine">
            <div id="slot-display">게임을 시작합니다...</div>
        </div>
<div id="game-over">
    <h2 id="game-over-text"></h2>
    <p>터뜨린 풍선: <span id="final-score">0</span>개</p>  <!-- 첫 번째 화면 - 유지 -->
    <div id="game-over-buttons">
        <button id="save-score-btn">기록저장</button>
        <button id="restart-btn">다시하기</button>
    </div>
    
<!-- 기록 표시 화면 (초기에는 숨김) -->
<div id="score-display" style="display: none;">
    <p>최고 기록: <span id="best-score-display">0</span>개</p>
    <button id="back-to-menu-btn">다시하기</button>
</div>
</div>
<audio id="pop-sound" preload="auto">
        <source src="https://cdn.freesound.org/previews/215/215851_4034520-lq.mp3" type="audio/mp3">
    </audio>
    <audio id="miss-sound" preload="auto">
        <source src="https://cdn.freesound.org/previews/626/626084_7108319-lq.mp3" type="audio/mp3">
    </audio>
    <audio id="game-over-sound" preload="auto">
        <source src="https://assets.mixkit.co/active_storage/sfx/2013/2013-preview.mp3" type="audio/mp3">
    </audio>
    <audio id="time-up-sound" preload="auto">
        <source src="https://assets.mixkit.co/active_storage/sfx/270/270-preview.mp3" type="audio/mp3">
    </audio>

    <script>
        // 게임 데이터
        const acupunctureData = {
            '폐경': ['소상', '어제', '태연', '경거', '척택'],
            '대장경': ['상양', '이간', '삼간', '양계', '곡지'],
            '위경': ['여태', '내정', '함곡', '해계', '족삼리'],
            '비경': ['은백', '대도', '태백', '상구', '음릉천'],
            '심경': ['소충', '소부', '신문', '영도', '少海'],
            '소장경': ['소택', '전곡', '후계', '양곡', '小海'],
            '방광경': ['지음', '통곡', '속골', '곤륜', '위중'],
            '신경': ['용천', '연곡', '태계', '부류', '음곡'],
            '심포경': ['중충', '노궁', '대릉', '간사', '곡택'],
            '삼초경': ['관충', '액문', '중저', '지구', '천정'],
            '담경': ['규음', '협계', '임읍', '양보', '양릉천'],
            '간경': ['대돈', '행간', '태충', '중봉', '곡천']
        };

        const osuHyeolTypes = ['정혈', '형혈', '수혈', '경혈', '합혈'];
        const osuHyeolIndices = {
            '정혈': 0,
            '형혈': 1,
            '수혈': 2,
            '경혈': 3,
            '합혈': 4
        };

        // 경맥 목록
        const meridians = Object.keys(acupunctureData);

        // 게임 상태
        let balloons = [];
        let currentProblem = null;
        let lives = 5;
        let score = 0;
        let gameRunning = true;
        let isSpinning = false;
        let usedAcupoints = []; 
        let isDartFlying = false; // 다트가 날아가는 중인지 확인하는 변수

        // 타이머 관련 변수
let gameTime = 120; // 2분 = 120초
let timerInterval = null;

        // 게임 요소
        const gameContainer = document.getElementById('game-container');
        const livesContainer = document.getElementById('lives-container');
        const slotDisplay = document.getElementById('slot-display');
        const scoreElement = document.getElementById('score');
        const gameOverElement = document.getElementById('game-over');
        const gameOverTextElement = document.getElementById('game-over-text');
        const finalScoreElement = document.getElementById('final-score');
        const restartBtn = document.getElementById('restart-btn');

        // 색상 팔레트
        const balloonColors = [
            '#FF6B6B', '#4ECDC4', '#FFD166', '#FF8360',
            '#E6E6EA', '#7DCFB6', '#FBD1A2', '#F79256',
            '#00B2CA', '#7EA16B', '#C1666B', '#D4A0A7'
        ];

        // 구름 생성
        function createClouds() {
            for (let i = 0; i < 8; i++) {
                const cloud = document.createElement('div');
                cloud.className = 'cloud';
                cloud.style.width = `${60 + Math.random() * 100}px`;
                cloud.style.height = `${40 + Math.random() * 60}px`;
                cloud.style.left = `${Math.random() * 100}%`;
                cloud.style.top = `${Math.random() * 60}%`;
                gameContainer.appendChild(cloud);
            }
        }

        // 생명 초기화
        function initLives() {
            livesContainer.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                livesContainer.appendChild(heart);
            }
        }

// 게임 시작 메시지 표시
function showStartMessage() {
    const messageElement = document.getElementById('instruction-message');
    
    // 메시지 요소 초기화
    messageElement.style.opacity = '0';
    messageElement.style.display = 'block';
    messageElement.classList.remove('fade-out');
    
    // 페이드 인 애니메이션
    setTimeout(() => {
        messageElement.classList.add('fade-in');
    }, 10); // 약간의 지연을 주어 애니메이션이 제대로 작동하도록 함
    
    // 2초 후 페이드 아웃
    setTimeout(() => {
        messageElement.classList.remove('fade-in');
        messageElement.classList.add('fade-out');
        
        // 애니메이션 완료 후 숨기기
        setTimeout(() => {
            messageElement.style.display = 'none';
        }, 300); // 페이드 아웃 애니메이션 시간과 일치
    }, 2000);
}

        // 문제 생성
function generateProblem() {
    if (isSpinning) return;
    isSpinning = true;

    // 슬롯 디스플레이 초기화
    slotDisplay.innerHTML = '';
    slotDisplay.style.overflow = 'hidden'; // 오버플로우 숨기기 강제 적용

    // 현재 풍선 중에서 랜덤으로 하나 선택 (정답이 될 풍선)
    const answerIndex = Math.floor(Math.random() * balloons.length);
    const answerBalloon = balloons[answerIndex];
    
    // 문제는 항상 "경맥의 오수혈 타입"으로 출제
    const problemText = `${answerBalloon.meridian}의 ${answerBalloon.type}`;
    
    // 문제 저장
    currentProblem = {
        type: 'osuHyeol',
        text: problemText,
        answer: answerBalloon
    };

    // 슬롯 머신 효과를 위한 임의 텍스트 생성
    const randomTexts = [
        '폐경의 형혈', '대장경의 정혈', '위경의 수혈', 
        '비경의 경혈', '심경의 합혈', '소장경의 정혈', 
        '방광경의 형혈', '신경의 수혈', '심포경의 경혈', 
        '삼초경의 합혈', '담경의 정혈', '간경의 형혈'
    ];
    
    // 애니메이션 시간 및 개수 조정
    const itemDuration = 200; // 각 아이템이 보여지는 시간(ms)
    const spinItems = 6; // 회전할 아이템 개수 (더 많이)
    let delay = 0;
    
    // 임의의 텍스트 순차적으로 애니메이션
    for (let i = 0; i < spinItems; i++) {
        const randomText = randomTexts[Math.floor(Math.random() * randomTexts.length)];
        const slotItem = document.createElement('div');
        slotItem.className = 'slot-item';
        slotItem.textContent = randomText;
        // 초기 위치를 확실히 밖으로 설정
        slotItem.style.transform = 'translateY(-200%)';
        slotItem.style.opacity = '0';
        
        slotDisplay.appendChild(slotItem);
        
        // 각 아이템의 애니메이션 시작 시간 지연
        setTimeout(() => {
            slotItem.classList.add('slot-spinning');
            
            // 애니메이션 완료 후 제거
            setTimeout(() => {
                if (slotItem.parentNode === slotDisplay) {
                    slotDisplay.removeChild(slotItem);
                }
            }, itemDuration + 50); // 약간 여유 시간 추가
        }, delay);
        
        // 시간 간격을 더 짧게 (겹치는 효과)
        delay += itemDuration * 0.6;
    }
    
    // 최종 텍스트 표시
    setTimeout(() => {
        // 마지막 슬롯 아이템 생성 (최종 결과)
        const finalItem = document.createElement('div');
        finalItem.className = 'slot-item';
        finalItem.textContent = problemText;
        finalItem.style.transform = 'translateY(-200%)';
        finalItem.style.opacity = '0';
        
        slotDisplay.appendChild(finalItem);
        
        // 마지막 아이템 애니메이션
        setTimeout(() => {
            // 이 아이템은 중앙에 멈춤
            finalItem.style.animation = 'none';
            finalItem.style.opacity = '1';
            finalItem.style.transform = 'translateY(0)';
            finalItem.style.position = 'static'; // 애니메이션 후 정적 위치로
            
            isSpinning = false;
        }, 50);
    }, delay + itemDuration);
}

        // 두 풍선 사이의 거리 계산
        function getDistance(balloon1, balloon2) {
            const dx = balloon1.x + 35 - (balloon2.x + 35); // 풍선 중심으로 계산
            const dy = balloon1.y + 45 - (balloon2.y + 45); // 풍선 중심으로 계산
            return Math.sqrt(dx * dx + dy * dy);
        }

        // 충돌 감지 및 해결
       function checkAndResolveCollisions() {
    const balloonRadius = 45; // 풍선 반지름
    const minDistance = balloonRadius * 2; // 두 풍선 사이 최소 거리
    
    // 모바일 환경에서는 충돌 감지 거리를 줄임 (더 가까울 때만 충돌 발생)
    const isMobile = window.innerWidth <= 768;
    const detectionDistance = isMobile ? minDistance * 0.9 : minDistance * 1.2; // 모바일에서 더 작은 감지 거리
    
    for (let i = 0; i < balloons.length; i++) {
        for (let j = i + 1; j < balloons.length; j++) {
            const balloon1 = balloons[i];
            const balloon2 = balloons[j];
            
            const distance = getDistance(balloon1, balloon2);
            
            // 충돌 감지 - 거리에 따른 점진적 반응
            if (distance < detectionDistance) {
                // 충돌 강도 계산 (거리에 따라 점진적으로)
                // 모바일에서는 충돌 강도를 더 약하게 조정
                const collisionStrength = isMobile 
                    ? Math.pow(1 - (distance / detectionDistance), 2.0) * 0.7 // 더 약한 충돌 강도
                    : Math.pow(1 - (distance / detectionDistance), 1.5);
                
                // 중간에 도달하지 않은 풍선 특별 처리
                if (!balloon1.reachedMiddle || !balloon2.reachedMiddle) {
                    // 상승 중인 풍선 식별
                    const risingBalloon = !balloon1.reachedMiddle ? balloon1 : balloon2;
                    const otherBalloon = risingBalloon === balloon1 ? balloon2 : balloon1;
                    
                    // 부드러운 회피 움직임 - 점진적 힘 적용
                    const dx = (risingBalloon.x + 35) - (otherBalloon.x + 35);
                    const dy = (risingBalloon.y + 45) - (otherBalloon.y + 45);
                    const length = Math.sqrt(dx * dx + dy * dy) || 1;
                    const nx = dx / length;
                    const ny = dy / length;
                    
                    // 충돌 강도에 따른 점진적 회피 (부드러운 이동)
                    // 모바일에서는 회피 요소 감소
                    const avoidFactor = isMobile
                        ? 2.0 * collisionStrength // 모바일에서 더 작은 회피 요소
                        : 2.5 * collisionStrength;
                    
                    // 위치 조정 (떨림 방지를 위해 x, y 동시 적용)
                    if (!risingBalloon.isAvoiding) {
                        risingBalloon.isAvoiding = true;
                        
                        // 이동 벡터 계산 - 부드러운 회피
                        // 모바일에서는 X축 회피 감소
                        let moveX = nx * avoidFactor * (isMobile ? 0.8 : 1.2);
                        let moveY = 0;
                        
                        // 상승 중인 풍선의 위치에 따라 수직 이동 조정
                        if (risingBalloon.y <= otherBalloon.y) {
                            moveY = ny * avoidFactor * (isMobile ? 0.5 : 0.3); // 모바일에서 더 큰 수직 이동
                        }
                        
                        // 부드러운 이동을 위해 애니메이션 효과 사용
                        animateBalloonAvoidance(risingBalloon, moveX, moveY);
                    }
                    
                    // 경계 유지
                    keepBalloonInBounds(risingBalloon);
                    continue; // 다른 처리는 건너뛰기
                }
                
                // 일반 충돌 처리 (둘 다 중간에 도달했을 때)
                // 부드러운 반발을 위해 더 약한 충격 적용
                // 모바일에서는 반발 효과 감소
                const overlap = (minDistance - distance) * collisionStrength * (isMobile ? 0.4 : 0.6);
                const dx = (balloon2.x + 35) - (balloon1.x + 35);
                const dy = (balloon2.y + 45) - (balloon1.y + 45);
                
                // 방향 벡터 정규화
                const length = Math.sqrt(dx * dx + dy * dy) || 1;
                const nx = dx / length;
                const ny = dy / length;
                
                // 반발력으로 풍선 점진적 이동 (더 부드럽게)
                // 모바일에서는 X축 반발력 감소, Y축 반발력 증가
                const repelFactor = isMobile ? 0.3 : 0.4; // 밀어내는 강도 조정
                
                // 모바일에서는 Y축 이동을 우선시
                const yFactor = isMobile ? 1.3 : 1.0; // 모바일에서 Y축 움직임 증가
                const xFactor = isMobile ? 0.6 : 1.0; // 모바일에서 X축 움직임 감소
                
                // 충돌 강도에 따른 점진적 속도 조정
                const balloon1MoveX = -nx * overlap * repelFactor * xFactor;
                const balloon1MoveY = -ny * overlap * repelFactor * yFactor;
                const balloon2MoveX = nx * overlap * repelFactor * xFactor;
                const balloon2MoveY = ny * overlap * repelFactor * yFactor;
                
                // 부드러운 이동 애니메이션 적용
                animateBalloonMovement(balloon1, balloon1MoveX, balloon1MoveY);
                animateBalloonMovement(balloon2, balloon2MoveX, balloon2MoveY);
                
                // 경계 내에 유지
                keepBalloonInBounds(balloon1);
                keepBalloonInBounds(balloon2);
                
                // 충돌 시 방향 조정 (모바일에서는 확률 더 낮춤)
                const dirChangeProb = isMobile ? 0.02 : 0.04;
                if (Math.random() < dirChangeProb) {
                    balloon1.direction *= -1;
                }
                
                if (Math.random() < dirChangeProb) {
                    balloon2.direction *= -1;
                }
            } else if (distance < detectionDistance * 1.5) {
                // 모바일에서는 이 미세 조정 감소 또는 비활성화
                if (!isMobile) {
                    // 충돌 임박 시 미세 조정 (아주 약한 힘)
                    const anticipationStrength = 0.1 * (1 - (distance / (detectionDistance * 1.5)));
                    
                    // 미세한 방향 조정을 통한 자연스러운 회피
                    const dx = (balloon2.x + 35) - (balloon1.x + 35);
                    const dy = (balloon2.y + 45) - (balloon1.y + 45);
                    const length = Math.sqrt(dx * dx + dy * dy) || 1;
                    const nx = dx / length;
                    const ny = dy / length;
                    
                    // 아주 약한 회피 힘
                    balloon1.x -= nx * anticipationStrength;
                    balloon2.x += nx * anticipationStrength;
                } else if (distance < detectionDistance * 1.2) {
                    // 모바일에서는 더 가까울 때만 약한 회피 힘 적용
                    const anticipationStrength = 0.05 * (1 - (distance / (detectionDistance * 1.2)));
                    
                    const dx = (balloon2.x + 35) - (balloon1.x + 35);
                    const dy = (balloon2.y + 45) - (balloon1.y + 45);
                    const length = Math.sqrt(dx * dx + dy * dy) || 1;
                    const nx = dx / length;
                    const ny = dy / length;
                    
                    // 매우 약한 회피 힘, 주로 Y축으로만
                    balloon1.y -= ny * anticipationStrength * 0.8;
                    balloon2.y += ny * anticipationStrength * 0.8;
                }
            }
        }
    }
}

// 풍선 회피 움직임을 부드럽게 애니메이션화
function animateBalloonAvoidance(balloon, moveX, moveY) {
    // 이미 애니메이션 중이면 취소
    if (balloon.avoidAnimationId) {
        clearTimeout(balloon.avoidAnimationId);
    }
    
    // 10개 단계로 나누어 점진적으로 이동
    const steps = 10;
    const stepX = moveX / steps;
    const stepY = moveY / steps;
    let currentStep = 0;
    
    function moveStep() {
        if (currentStep < steps && balloon.element.parentNode) {
            balloon.x += stepX;
            balloon.y += stepY;
            
            // 경계 확인
            keepBalloonInBounds(balloon);
            
            // 다음 단계
            currentStep++;
            balloon.avoidAnimationId = setTimeout(moveStep, 10);
        } else {
            balloon.isAvoiding = false;
            balloon.avoidAnimationId = null;
        }
    }
    
    // 애니메이션 시작
    moveStep();
}

// 충돌 후 풍선 이동을 부드럽게 애니메이션화
function animateBalloonMovement(balloon, moveX, moveY) {
    // 이미 애니메이션 중이면 취소하지 않고 위치만 업데이트
    if (!balloon.isMoving) {
        balloon.isMoving = true;
        
        // 5개 단계로 나누어 점진적으로 이동
        const steps = 5;
        const stepX = moveX / steps;
        const stepY = moveY / steps;
        let currentStep = 0;
        
        function moveStep() {
            if (currentStep < steps && balloon.element.parentNode) {
                balloon.x += stepX;
                balloon.y += stepY;
                
                // 경계 확인
                keepBalloonInBounds(balloon);
                
                // 다음 단계
                currentStep++;
                setTimeout(moveStep, 8);
            } else {
                balloon.isMoving = false;
            }
        }
        
        // 애니메이션 시작
        moveStep();
    } else {
        // 이미 움직이는 중이면 위치만 업데이트
        balloon.x += moveX / 2;
        balloon.y += moveY / 2;
        keepBalloonInBounds(balloon);
    }
}

        // 풍선이 경계 내에 있도록 유지
function keepBalloonInBounds(balloon) {
    if (balloon.x < balloon.movementLimit.left) {
        balloon.x = balloon.movementLimit.left;
        balloon.directionX = 1; // 오른쪽으로 방향 전환
    } else if (balloon.x > balloon.movementLimit.right) {
        balloon.x = balloon.movementLimit.right;
        balloon.directionX = -1; // 왼쪽으로 방향 전환
    }
    
    // 상승 중인 풍선은 위 경계에 닿았을 때만 아래로 방향 전환
    if (balloon.y < balloon.movementLimit.top) {
        balloon.y = balloon.movementLimit.top;
        balloon.direction = 1; // 아래로 방향 전환
    } 
    // 중간에 도달한 풍선만 아래쪽 경계 적용
    else if (balloon.reachedMiddle && balloon.y > balloon.movementLimit.bottom) {
        balloon.y = balloon.movementLimit.bottom;
        balloon.direction = -1; // 위로 방향 전환
    }
    
    // 특별한 경우: 만약 상승 중인 풍선(reachedMiddle=false)이 아래쪽으로 너무 내려갔다면
    if (!balloon.reachedMiddle && balloon.y > gameContainer.clientHeight) {
        // 풍선을 다시 화면 아래에서 시작하게 함
        balloon.y = gameContainer.clientHeight + Math.random() * 50;
        balloon.direction = -1; // 다시 위로 올라가게 설정
    }
}

        // 새 풍선이 기존 풍선과 충돌하지 않는 위치 찾기
        function findNonCollidingPosition() {
            const balloonSize = 70;
            const width = gameContainer.clientWidth;
            const availableWidth = width - balloonSize;
            const minDistance = 90; // 최소 거리
            let retries = 0;
            const maxRetries = 30; // 최대 시도 횟수
            
            while (retries < maxRetries) {
                // 무작위 위치 생성
                const x = Math.random() * (availableWidth - 20) + 10;
                const y = gameContainer.clientHeight + Math.random() * 100;
                
                // 기존 풍선과 충돌 검사
                let collision = false;
                for (const balloon of balloons) {
                    const dx = balloon.x - x;
                    const dy = balloon.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < minDistance) {
                        collision = true;
                        break;
                    }
                }
                
                // 충돌 없으면 위치 반환
                if (!collision) {
                    return { x, y };
                }
                
                retries++;
            }
            
            // 충돌 없는 위치를 찾지 못했으면 화면 밖에서 시작
            return { 
                x: Math.random() * (availableWidth - 20) + 10, 
                y: gameContainer.clientHeight + 100 + Math.random() * 100
            };
        }

        // 풍선 생성
       function createBalloon() {
    // 사용 가능한 혈명 찾기 (최대 30회 시도)
    let selectedMeridian, selectedAcupoint, type, randomAcupointIndex;
    let attempts = 0;
    const maxAttempts = 30;
    let acupointFound = false;
    
    while (!acupointFound && attempts < maxAttempts) {
        // 경맥 랜덤 선택
        const randomMeridianIndex = Math.floor(Math.random() * meridians.length);
        selectedMeridian = meridians[randomMeridianIndex];

        // 경맥의 혈자리 목록
        const acupoints = acupunctureData[selectedMeridian];
        
        // 사용 가능한 혈자리 찾기
        const availableIndices = [];
        for (let i = 0; i < acupoints.length; i++) {
            // 현재 사용 중인 혈명인지 확인
            const acupoint = acupoints[i];
            if (!usedAcupoints.includes(acupoint)) {
                availableIndices.push(i);
            }
        }
        
        // 사용 가능한 혈자리가 있으면 선택
        if (availableIndices.length > 0) {
            const randomIndex = Math.floor(Math.random() * availableIndices.length);
            randomAcupointIndex = availableIndices[randomIndex];
            selectedAcupoint = acupoints[randomAcupointIndex];
            type = osuHyeolTypes[randomAcupointIndex];
            acupointFound = true;
        }
        
        attempts++;
    }
    
    // 만약 모든 혈명이 사용 중이라면, 이미 사용 중인 것 중에서 선택
    if (!acupointFound) {
        // 경맥 랜덤 선택
        const randomMeridianIndex = Math.floor(Math.random() * meridians.length);
        selectedMeridian = meridians[randomMeridianIndex];

        // 경맥의 혈자리 랜덤 선택
        const acupoints = acupunctureData[selectedMeridian];
        randomAcupointIndex = Math.floor(Math.random() * acupoints.length);
        selectedAcupoint = acupoints[randomAcupointIndex];
        type = osuHyeolTypes[randomAcupointIndex];
        
        console.log("모든 혈명이 사용 중입니다. 중복 허용: " + selectedAcupoint);
    }
    
    // 사용 중인 혈명 목록에 추가
    usedAcupoints.push(selectedAcupoint);
    
    // 풍선 요소 생성
    const balloonElement = document.createElement('div');
    balloonElement.className = 'balloon';

    // 랜덤 색상 선택
    const colorIndex = Math.floor(Math.random() * balloonColors.length);
    balloonElement.style.backgroundColor = balloonColors[colorIndex];

    // 풍선 텍스트 설정
    balloonElement.textContent = selectedAcupoint;

    // 기존 풍선과 겹치지 않는 위치 찾기
    const position = findNonCollidingPosition();
    const x = position.x;
    const y = position.y;

    balloonElement.style.left = `${x}px`;
    balloonElement.style.top = `${y}px`;

    // 풍선 클릭 이벤트
balloonElement.addEventListener('click', () => {
    if (gameRunning && currentProblem && !isDartFlying) {
        // 현재 balloon 객체를 찾아 전달
        const currentBalloon = balloons.find(b => b.element === balloonElement);
        if (currentBalloon) {
            throwDart(balloonElement, currentBalloon);
        }
    }
});

    gameContainer.appendChild(balloonElement);

    // 속도를 원래의 1/3로 설정
    const originalSpeed = (0.8 + Math.random() * 0.4) / 1.5;
    const reducedSpeed = originalSpeed / 3;

    // 모바일 환경 체크 (화면 너비 768px 이하)
const isMobile = window.innerWidth <= 768;

// 풍선 객체 생성
const balloon = {
    element: balloonElement,
    x,
    y,
    speed: reducedSpeed,
    speedX: 0,
    direction: -1,
    directionX: 0,
    meridian: selectedMeridian,
    acupoint: selectedAcupoint,
    type,
    reachedMiddle: false,
    avoidingCollision: false,
    originalSpeed: null,
    speedBoosted: false,
    isAvoiding: false,     // 회피 중 상태 추가
    isMoving: false,       // 이동 중 상태 추가
    avoidAnimationId: null, // 애니메이션 ID 저장용
    // 모바일에서는 각 풍선마다 개별적인 중간 높이 설정
    targetMiddleHeight: isMobile ? gameContainer.clientHeight * (0.4 + Math.random() * 0.3) : null,
    movementLimit: {
        top: 50,
        bottom: gameContainer.clientHeight - 200,
        left: 10,
        right: gameContainer.clientWidth - 80
    }
};

    return balloon;
}

        // 다트 던지기
function throwDart(targetElement, balloon) {
    if (!currentProblem || isDartFlying) return;
    
    isDartFlying = true; // 다트 날아가는 상태로 설정

    const dartElement = document.createElement('div');
    dartElement.className = 'flying-dart';

            // 슬롯 머신 위치 (다트 시작 위치)
            const slotRect = document.getElementById('slot-machine').getBoundingClientRect();
            const startX = slotRect.left + slotRect.width / 2 - 10;
            const startY = slotRect.top - 40;
            
            dartElement.style.left = `${startX}px`;
            dartElement.style.top = `${startY}px`;

            document.body.appendChild(dartElement);

            // 다트 목표 위치
            const targetRect = targetElement.getBoundingClientRect();
            const targetX = targetRect.left + targetRect.width / 2 - 10;
            const targetY = targetRect.top + targetRect.height / 2 - 20;

            // 다트 날아가는 애니메이션
            const startTime = performance.now();
            const animationDuration = 500; // 0.5초

          function animateDart(currentTime) {
    const elapsedTime = currentTime - startTime;
    const progress = Math.min(elapsedTime / animationDuration, 1);

    const x = startX + (targetX - startX) * progress;
    const y = startY + (targetY - startY) * progress;

    dartElement.style.left = `${x}px`;
    dartElement.style.top = `${y}px`;
    dartElement.style.transform = `rotate(${progress * 360}deg)`;

    if (progress < 1) {
        // 다트가 목표물에 거의 도달했을 때 (90% 이상) 소리 재생 준비
        if (progress > 0.9 && !dartElement.soundPlayed && balloon !== currentProblem.answer) {
            // 오답 풍선일 경우만 미리 소리 준비 (맞는 풍선은 popBalloon에서 처리)
            dartElement.soundPlayed = true;
        }
        requestAnimationFrame(animateDart);
} else {
    // 다트 도착
    document.body.removeChild(dartElement);
    checkHit(balloon);
    isDartFlying = false; // 다트가 목표에 도착했으므로 상태 해제
}
}

            requestAnimationFrame(animateDart);
        }

        // 풍선 맞췄는지 확인
        function checkHit(balloon) {
    let isHit = false;

    // 정답 확인 - 선택한 풍선이 정답 풍선인지 직접 비교
    if (balloon === currentProblem.answer) {
        isHit = true;
    }

    if (isHit) {
        // 풍선 터트리기
        popBalloon(balloon);
        score++;
        scoreElement.textContent = score;
        
        // 새 문제 출제 전에 새 풍선 생성
        setTimeout(() => {
            // 새 풍선 생성
            if (balloons.length < 5) {
                const newBalloon = createBalloon();
                balloons.push(newBalloon);
            }
            
            // 새 문제 출제
            generateProblem();
        }, 500);
    } else {
        // 실패 시 효과음 재생
        const missSound = document.getElementById('miss-sound');
        missSound.currentTime = 0;
        missSound.play();
        
        // 실패 시 생명 감소
        decreaseLives();
    }
}

        // 풍선 터트리기
       function popBalloon(balloon) {
    balloon.element.classList.add('balloon-pop');
    
    // 풍선 터지는 효과음 재생
    const popSound = document.getElementById('pop-sound');
    popSound.currentTime = 0; // 소리를 처음부터 재생
    popSound.play();

    setTimeout(() => {
        if (balloon.element.parentNode === gameContainer) {
            gameContainer.removeChild(balloon.element);
        }

        // 배열에서 풍선 제거
        const index = balloons.findIndex(b => b.element === balloon.element);
        if (index !== -1) {
            balloons.splice(index, 1);
            
            // 사용 중인 혈명 목록에서 제거
            const acupointIndex = usedAcupoints.indexOf(balloon.acupoint);
            if (acupointIndex !== -1) {
                usedAcupoints.splice(acupointIndex, 1);
            }
        }
    }, 300);
}

        // 생명 감소
        function decreaseLives() {
            lives--;
            updateLives();

            if (lives <= 0) {
                endGame();
            }
        }

        // 생명 표시 업데이트
        function updateLives() {
            livesContainer.innerHTML = '';
            for (let i = 0; i < lives; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                livesContainer.appendChild(heart);
            }
        }

// 게임 종료
function endGame() {
    gameRunning = false;
    
    // 타이머 애니메이션 중지
    const timerContainer = document.getElementById('timer-container');
    timerContainer.style.animation = 'none';
    
    gameOverTextElement.textContent = '게임 종료';
    finalScoreElement.textContent = score;
    gameOverElement.style.display = 'block';
    
    // 게임 오버 효과음 재생
    const gameOverSound = document.getElementById('game-over-sound');
    gameOverSound.play();
    
    // 타이머 중지
    if (timerInterval) {
        clearInterval(timerInterval);
    }
}

      function updateBalloons() {
    // 슬롯머신 위치 계산 (매 프레임마다)
    const slotMachine = document.getElementById('slot-machine');
    const slotMachineRect = slotMachine.getBoundingClientRect();
    const slotMachineTop = slotMachineRect.top - gameContainer.getBoundingClientRect().top;
    const safeBottom = slotMachineTop - 120; // 슬롯머신 위 120px까지 안전 영역
    
    // 모바일 환경 체크 (화면 너비 768px 이하)
    const isMobile = window.innerWidth <= 768;
    
    // 각 풍선 움직임 업데이트
    for (const balloon of balloons) {
        // 풍선이 화면 외부 너무 아래로 내려갔는지 확인
        if (balloon.y > gameContainer.clientHeight * 1.5) {
            // 화면 아래로 너무 내려간 경우 다시 아래에서 시작
            balloon.y = gameContainer.clientHeight + 50 + Math.random() * 100;
            balloon.direction = -1; // 반드시 위로 올라가도록 설정
            balloon.reachedMiddle = false; // 중간 도달 상태 초기화
        }
        
        // 처음에는 위로만 올라가기
        if (!balloon.reachedMiddle) {
            // 중간 높이까지 올라갈 때 속도 조정 (부드럽게)
            balloon.y += balloon.speed * balloon.direction * 7;
            
            // 중간 높이에 도달했는지 확인
            let middleHeight;
            if (isMobile) {
                // 모바일에서는 0.4에서 0.7 사이의 무작위 지점에서 랜덤 움직임 시작
                if (!balloon.targetMiddleHeight) {
                    // 처음 생성된 풍선에 대해 목표 중간 높이 설정
                    balloon.targetMiddleHeight = gameContainer.clientHeight * (0.4 + Math.random() * 0.3);
                }
                middleHeight = balloon.targetMiddleHeight;
            } else {
                // 데스크톱에서는 기존대로 화면 중간(0.5) 지점
                middleHeight = gameContainer.clientHeight * 0.5;
            }

            if (balloon.y <= middleHeight) {
                balloon.reachedMiddle = true;
                
                // 중간 높이에 도달하면 랜덤 방향 설정
                balloon.directionX = Math.random() > 0.5 ? 1 : -1;
                
                // 모바일에서는 X축 속도를 조정 (좌우 이동 적절히 증가)
                if (isMobile) {
                    balloon.speedX = balloon.speed * (0.3 + Math.random() * 0.25); // X축 속도 약간 높게 설정
                } else {
                    balloon.speedX = balloon.speed * (0.5 + Math.random() * 0.5); // 기존 X축 속도
                }
            }
        } else {
            // 모바일에서는 Y축 속도와 X축 속도 균형 조정
            let ySpeedMultiplier, xSpeedMultiplier;

            if (isMobile) {
                // 모바일에서는 상하 움직임 강조하되 좌우 움직임도 적절히 유지
                ySpeedMultiplier = 2 * 1.1;   // Y축 속도 (10% 증가)
                xSpeedMultiplier = 2 * 0.5;   // X축 속도 (50% 감소, 이전보다 증가)
            } else {
                // 데스크톱에서는 기존 속도 유지
                ySpeedMultiplier = 2;
                xSpeedMultiplier = 2;
            }
            // 움직임 적용
            balloon.y += balloon.speed * balloon.direction * ySpeedMultiplier;
            balloon.x += balloon.speedX * balloon.directionX * xSpeedMultiplier;
            
            // 슬롯머신 영역 침범 방지 (동적으로 계산)
            if (balloon.y > safeBottom) {
                balloon.y = safeBottom;
                balloon.direction = -1; // 강제로 위로 방향 전환
            }
            
            // 움직임 제한 적용 (슬롯머신 영역 제외)
            balloon.movementLimit.bottom = safeBottom; // 동적으로 업데이트
            keepBalloonInBounds(balloon);
            
            // 방향 랜덤 변경 (모바일에서 방향 전환 확률 조정)
            if (isMobile) {
                if (Math.random() < 0.0025) { // Y축 방향 전환 확률 (약간 증가)
                    balloon.direction *= -1;
                }
                if (Math.random() < 0.005) { // X축 방향 전환 확률 (약간 더 증가)
                    balloon.directionX *= -1;
                }
            } else {
                // 데스크톱에서는 기존 확률 유지
                if (Math.random() < 0.003) {
                    balloon.direction *= -1;
                }
                if (Math.random() < 0.003) {
                    balloon.directionX *= -1;
                }
            }
        }
        
        // 위치 업데이트
        balloon.element.style.top = `${balloon.y}px`;
        balloon.element.style.left = `${balloon.x}px`;
    }
    
    // 충돌 감지 및 해결
    checkAndResolveCollisions();
}

// 타이머 초기화
function initTimer() {
    gameTime = 120; // 2분으로 초기화
    
    // 타이머 컨테이너 스타일 리셋
    const timerContainer = document.getElementById('timer-container');
    timerContainer.style.animation = 'none';
    const timerBar = document.getElementById('timer-bar');
    timerBar.style.background = 'linear-gradient(to right, #FF5252, #FF8A80)'; // 원래 색상으로 복원

    // 리플로우 강제 실행 (스타일 변경사항 적용)
    void timerContainer.offsetWidth;
    
    updateTimerDisplay();
    
    // 이전 타이머가 있다면 정리
    if (timerInterval) {
        clearInterval(timerInterval);
    }
    
    // 1초마다 타이머 업데이트
    timerInterval = setInterval(() => {
        if (gameRunning) {
            gameTime--;
            updateTimerDisplay();
            
            // 시간이 다 되었을 때
            if (gameTime <= 0) {
                clearInterval(timerInterval);
                endGameByTimeout();
            }
        }
    }, 1000);
}

// 타이머 표시 업데이트
function updateTimerDisplay() {
    const minutes = Math.floor(gameTime / 60);
    const seconds = gameTime % 60;
    const formattedTime = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    
    document.getElementById('timer-text').textContent = formattedTime;
    
    // 시간바 업데이트 (120초 기준으로 비율 계산)
    const percentage = (gameTime / 120) * 100;
    document.getElementById('timer-bar').style.width = `${percentage}%`;
    
    // 시간이 적게 남았을 때 시각적 알림
    if (gameTime <= 30) {
        document.getElementById('timer-bar').style.background = 'linear-gradient(to right, #FF0000, #FF5252)';
        
        // 10초 이하일 때 깜빡임 효과
        if (gameTime <= 10) {
            document.getElementById('timer-container').style.animation = 'pulse 0.5s infinite alternate';
        }
    }
}

// 시간 초과로 게임 종료
function endGameByTimeout() {
    gameRunning = false;
    
    // 타이머 애니메이션 중지
    const timerContainer = document.getElementById('timer-container');
    timerContainer.style.animation = 'none';
    
    gameOverTextElement.textContent = '게임 종료';
    finalScoreElement.textContent = score;
    gameOverElement.style.display = 'block';
    
    // 시간 초과 효과음 재생
    const timeUpSound = document.getElementById('time-up-sound');
    timeUpSound.play();
}

function initGame() {
    // 이전 풍선 제거
    balloons.forEach(balloon => {
        if (balloon.element.parentNode === gameContainer) {
            gameContainer.removeChild(balloon.element);
        }
    });
    balloons = [];
    usedAcupoints = []; // 사용 중인 혈명 목록 초기화

// 게임 상태 초기화
lives = 5;
score = 0;
gameRunning = true;
currentProblem = null;
isDartFlying = false; // 게임 재시작 시 다트 상태도 초기화

    // UI 업데이트
    scoreElement.textContent = score;
    gameOverElement.style.display = 'none';

    // 요소 초기화
    initLives();
    initTimer();
    
    // 게임 시작 메시지 표시
    showStartMessage();

    // 초기 풍선 생성 (항상 5개)
    // 겹치지 않게 하나씩 생성
    for (let i = 0; i < 5; i++) {
        const balloon = createBalloon();
        balloons.push(balloon);
    }

    // 첫 문제 출제
    setTimeout(generateProblem, 1000);
}
// 로컬스토리지 관련 함수들
function saveScoreToLocal(score) {
    const bestScore = localStorage.getItem('bestScore');
    if (!bestScore || score > parseInt(bestScore)) {
        localStorage.setItem('bestScore', score.toString());
        return true; // 새로운 최고 기록
    }
    return false; // 기존 기록 유지
}

function getBestScore() {
    const bestScore = localStorage.getItem('bestScore');
    return bestScore ? parseInt(bestScore) : 0;
}

function showScoreDisplay() {
    document.getElementById('game-over-buttons').style.display = 'none';
    document.getElementById('score-display').style.display = 'block';
    
    document.getElementById('best-score-display').textContent = getBestScore();
}

// 기록저장 버튼 이벤트
document.getElementById('save-score-btn').addEventListener('click', () => {
    saveScoreToLocal(score);
    showScoreDisplay();
});

// 돌아가기 버튼 이벤트
document.getElementById('back-to-menu-btn').addEventListener('click', () => {
    document.getElementById('score-display').style.display = 'none';
    document.getElementById('game-over-buttons').style.display = 'block';
    initGame();
});
        // 게임 루프
        function gameLoop() {
            if (gameRunning) {
                updateBalloons();
            }
            requestAnimationFrame(gameLoop);
        }

        // 이벤트 리스너
        restartBtn.addEventListener('click', initGame);

        // 게임 시작
        createClouds();
        initGame();
        gameLoop();
    </script>
</body>
</html>